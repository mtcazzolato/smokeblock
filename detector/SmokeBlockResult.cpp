/**
* Copyright (C) 2015 Mirela Teixeira Cazzolato <mirelac@usp.br>
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*
* RESCUER Project
* Reliable and Smart Crowdsourcing Solution for Emergency and Crisis Management
* Smoke Block Classifier
*/

#include "SmokeBlockResult.hpp"

/**
 * Constructor
 */
SmokeBlockResult::SmokeBlockResult()
{
    this->what = -1;
}

/**
 * Constructor
 * @param mbrs Points concerning the Minimum Bound Rectangles (MBRs)
 * @param colorIntensity The color intensity of the smoke region detected
 * @param what The "What" tag, with 1 for "smoke", and 0 otherwise
 */
/**
 * Constructor
 * @param mbrs MBRs of the identified smoke regions
 * @param what "what" tag of the image (0 for non-smoke and 1 for smoke)
 */
SmokeBlockResult::SmokeBlockResult(std::vector< std::pair< std::pair<int, int>, std::pair<int, int> > > mbrs, int what)
{
	this->mbrs = mbrs;
	this->what = what;
}

/**
 * Destructor
 */
SmokeBlockResult::~SmokeBlockResult()
{

}

/**
 * Set the Minimum Bounding Rectangles detected, concerning to the smoke regions
 * @param mbrs Coordinate points concerning the Minimum Bound Rectangles (MBRs)
 */
void SmokeBlockResult::setResultingMBR(std::vector< std::pair< std::pair<int, int>, std::pair<int, int> > > mbrs)
{
	this->mbrs = mbrs;
}

/**
 * Get the MBRs results generated by SmokeBlock
 * @return Vector of pairs of points (top left and bottom right points)
 */
std::vector< std::pair< std::pair<int, int>, std::pair<int, int> > > SmokeBlockResult::getResultingMBR()
{
    return this->mbrs;
}

/**
 * Set mean RGB color of each MBR, and convert all colors to HSV color space
 * @param colors Vector of RGB colors (in BGR order)
 */
void SmokeBlockResult::setResultingMeanColors(std::vector<CvScalar> colors)
{
    this->resultingMeanColors = colors; /// (B,G,R)
        
    /// Convert RGB to HSV and store results
    for (int i = 0; i < colors.size(); i++)
    {
        RGB2HSV(colors[i]);
    }
}

/**
 * Get the RGB mean color values (in BGR order)
 * @return RGB color values (in BGR order)
 */
//vector<CvScalar> SmokeBlockResult::getResultingBGRMeanColors()
std::vector<CvScalar> SmokeBlockResult::getResultingBGRMeanColors()
{
    return this->resultingMeanColors;
}


/**
 * Convert RGB color values to HSV color space
 * @param BGRcolor RGB color values (in BGR order)
 */
void SmokeBlockResult::RGB2HSV(CvScalar BGRcolor)
{
    /// Ranges: h = [0, 360] || s = [0, 1] || v = [0, 1]
    
    float b = BGRcolor.val[0] / 255;
    float g = BGRcolor.val[1] / 255;
    float r = BGRcolor.val[2] / 255;
    float min, max, delta;
    float h, s, v;
    
    min = std::min(r, std::min(g, b));
    max = std::max(r, std::max(g, b));
    
    v = max; /// V
    
    delta = max - min;
    
    if (max == 0) /// R = G = B = 0, so S = 0 and V is undefined
    {
        s = 0;
        h = -1;
    }
    else
    {
        s = delta / max; /// S
        
        if (r == max)
            h = (g - b) / delta;
        else
            if (g == max)
                h = 2 + (b - r) / delta;
            else
                h = 4 + (r - g) / delta;
        
        h *= 60;
        if (h < 0)
            h += 360;
    }
    
    this->hColors.push_back(h);
    this->sColors.push_back(s);
    this->vColors.push_back(v);
}

/**
 * Set resulting hue channel value for all MBRs
  * @param h Hue channel values of all MBRs
 */
void SmokeBlockResult::setResultingHColor(std::vector<float> h)
{
    this->hColors = h;
}

/**
 * Get the Hue channel values of all mbrs
 * @return Hue channel values of all mbrs
 */
std::vector< float > SmokeBlockResult::getResultingHColor()
{
    return this->hColors;
}

/**
 * Set resulting Saturation channel value for all MBRs
  * @param s Saturation channel values of all MBRs
 */
void SmokeBlockResult::setResultingSColor(std::vector<float> s)
{
    this->sColors = s;
}

/**
 * Get the Saturation channel values of all mbrs
 * @return Saturation channel values of all mbrs
 */
std::vector< float > SmokeBlockResult::getResultingSColor()
{
    return this->sColors;
}

/**
 * Set resulting Value channel value for all MBRs
  * @param v Value channel values of all MBRs
 */
void SmokeBlockResult::setResultingVColor(std::vector<float> v)
{
    this->vColors = v;
}

/**
 * Get the Value channel values of all mbrs
 * @return Value channel values of all mbrs
 */
std::vector< float > SmokeBlockResult::getResultingVColor()
{
    return this->vColors;
}

/**
 * Set the "What" tag, with 1 if image was classified as "smoke", and 0 otherwise
 * @param what the "What" tag
 */
void SmokeBlockResult::setResultingWhatTag(int what)
{
	this->what = what;
}

/**
 * Get the "What" tag, with 1 if the image was classified as "smoke", and 0 otherwise
 * @return int the "What" tag
 */
int SmokeBlockResult::getResultingWhatTag()
{
	return this->what;
}

/**
 * Set resulting segmented image
 * @param segmentedImage Resulting segmented image
 */
void SmokeBlockResult::setResultingImage(cv::Mat *segmentedImage)
{
    this->segmentedImage = segmentedImage;
}

/**
 * Get the resulting segmented image
 * @return Segmented image
 */
cv::Mat* SmokeBlockResult::getResultingImage()
{
    return this->segmentedImage;
}
